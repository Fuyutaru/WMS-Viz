// in your store (e.g. stores/wmsStore.js)
import { defineStore } from "pinia";

export const useWmsStore = defineStore("wms", {
  state: () => ({
    capabilitiesUrl: "",
    layerList: [],
    layersDict: {},
    wmsEndpoint: "",   // base URL of WMS
    outputFormats: [], // supported GetMap formats
    selectedLayer: {},
  }),
  getters: {
    isValidUrl(state) {
      return state.capabilitiesUrl.startsWith("http");
    },
    getLayerList(state) {
      return state.layerList;
    },
    getLayersDict(state) {
      return state.layersDict;
    },
    getWmsEndpoint(state) {
      return state.wmsEndpoint;
    },
    getOutputFormats(state) {
      return state.outputFormats;
    },
    getSelectedLayer(state) {
      return state.selectedLayer;
    },
    getLayerFitBounds: (state) => (layerName) => {
      const layer = state.layersDict[layerName];
      if (!layer || !layer.bbox) return null;

      const { minx, miny, maxx, maxy } = layer.bbox;

      return [
        [minx, miny],
        [maxx, maxy]
      ];
    },
  },
  actions: {
    setUrl(url) {
      this.capabilitiesUrl = 'http://localhost:3001/proxy?target=' + encodeURIComponent(url);
    },
    addSelectedLayer(layer) {
      for (let key in this.selectedLayer) {
        if (this.selectedLayer[key].name === layer.name) {
          return;
        }
      }
      this.selectedLayer[layer.name] = layer;
    },

    removeSelectedLayer(layerName) {
      if (this.selectedLayer[layerName]) {
        delete this.selectedLayer[layerName];
      }
    },
    async fetchCapabilities() {
      if (!this.capabilitiesUrl) {
        throw new Error("URL non dÃ©finie");
      }
      try {
        const response = await fetch(this.capabilitiesUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const text = await response.text();
        return text;
      } catch (err) {
        console.error("Erreur fetchCapabilities:", err);
        throw err;
      }
    },
    async parseAndStoreCapabilities() {
      // fetch the capabilities XML
      const text = await this.fetchCapabilities();
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, "application/xml");

      const root = xml.querySelector("WMS_Capabilities, WMT_MS_Capabilities");
      const version = root ? root.getAttribute("version") : "1.1.1";

      console.log("Parsed WMS version:", version);

      // check for parser errors
      const parserError = xml.querySelector("parsererror");
      if (parserError) {
        console.error("Error parsing XML:", parserError.textContent);
        throw new Error("Invalid XML in capabilities");
      }

      // 1. Extract WMS endpoint base URL
      const getMapNode = xml.querySelector("Capability > Request > GetCapabilities > DCPType > HTTP > Get > OnlineResource");
      let endpoint = "";
      if (getMapNode) {
        // OnlineResource may have attributes xlink:href or href
        endpoint = getMapNode.getAttribute("xlink:href") || getMapNode.getAttribute("href") || "";
      }
      if (!endpoint) {
        // strip off query params from the capabilities URL
        endpoint = this.capabilitiesUrl.split('?')[0];
      }
      this.wmsEndpoint = endpoint;

      // 2. Extract output formats supported by GetMap
      const formatNodes = xml.querySelectorAll("Capability > Request > GetMap > Format");
      const formats = Array.from(formatNodes).map(fn => fn.textContent.trim());
      this.outputFormats = formats;

      // 3. Extract layers: name, styles, bbox
      const layersDict = {};
      const layerNodes = xml.querySelectorAll("Capability > Layer Layer");  
      // Note: in WMS Capabilities, there's a root <Layer> and then nested <Layer> elements.
      // We want the ones that have a <Name> child (named layers), so filter out group-only layers.

      layerNodes.forEach(layerEl => {
        const nameEl = layerEl.querySelector("Name");
        if (!nameEl) return;  // skip layers without a name
        const layerName = nameEl.textContent.trim();

        // get styles: collection of style names and title or legend URL if present
        const styles = Array.from(layerEl.querySelectorAll("Style")).map(styleEl => {
          const styleNameEl = styleEl.querySelector("Name");
          const styleTitleEl = styleEl.querySelector("Title");
          const legendURLnode = styleEl.querySelector("LegendURL OnlineResource, or LegendURL > Format etc");
          const legendURL = legendURLnode 
            ? (legendURLnode.getAttribute("xlink:href") || legendURLnode.getAttribute("href") || "") 
            : "";
          return {
            name: styleNameEl ? styleNameEl.textContent.trim() : null,
            title: styleTitleEl ? styleTitleEl.textContent.trim() : null,
            legend: legendURL
          };
        });


        let bbox = null;
        if (version === "1.1.1") {
          const llbboxEl = layerEl.querySelector("LatLonBoundingBox");
          if (llbboxEl) {
            bbox = {
              srs: "EPSG:4326",
              minx: parseFloat(llbboxEl.getAttribute("minx")),
              miny: parseFloat(llbboxEl.getAttribute("miny")),
              maxx: parseFloat(llbboxEl.getAttribute("maxx")),
              maxy: parseFloat(llbboxEl.getAttribute("maxy"))
            };
          }
        } else if (version === "1.3.0") {
          const exBBoxEl = layerEl.querySelector("EX_GeographicBoundingBox");
          if (exBBoxEl) {
            bbox = {
              srs: "EPSG:4326",
              minx: parseFloat(exBBoxEl.querySelector("westBoundLongitude")?.textContent),
              miny: parseFloat(exBBoxEl.querySelector("southBoundLatitude")?.textContent),
              maxx: parseFloat(exBBoxEl.querySelector("eastBoundLongitude")?.textContent),
              maxy: parseFloat(exBBoxEl.querySelector("northBoundLatitude")?.textContent)
            };
          }
        } else {
          const bboxEl = layerEl.querySelector("BoundingBox");
          if (bboxEl) {
            bbox = {
              srs: bboxEl.getAttribute("SRS") || bboxEl.getAttribute("CRS") || null,
              minx: parseFloat(bboxEl.getAttribute("minx")),
              miny: parseFloat(bboxEl.getAttribute("miny")),
              maxx: parseFloat(bboxEl.getAttribute("maxx")),
              maxy: parseFloat(bboxEl.getAttribute("maxy"))
            };
          }
        }

        const titleEl = layerEl.querySelector("Title");
        const abstractEl = layerEl.querySelector("Abstract");

        layersDict[layerName] = {
          name: layerName,
          title: titleEl ? titleEl.textContent.trim() : null,
          abstract: abstractEl ? abstractEl.textContent.trim() : null,
          styles,
          bbox,
        };
      });

      this.layersDict = layersDict;
      this.layerList = Object.values(layersDict);
    },
  }
});
